<defun name="pfd_fork_compute">

  <include-structs href="types.xpnet"/>

  <require key="worker" mandatory="true"/>
  <tunnel name="in" type="unsigned int" place="in"/>
  <tunnel name="step" type="string" place="step"/>
  <tunnel name="options" type="options_type" place="options"/>
  <tunnel name="decomposition" type="unsigned int" place="decomposition"/>

  <net>
    <place name="in" type="unsigned int" virtual="true"/>
    <place name="step" type="string" virtual="true"/>

    <!--
    <place name="init_active" type="unsigned int">
      <token><value> 0U </value></token>
    </place>
    -->
    <!--
    <place name="finish_active" type="unsigned int"/>
    -->
    <place name="terms" type="term"/>
    <place name="decomposed_terms" type="term"/>

    <place name="decomposition" type="unsigned int" virtual="true"/>

    <place name="term_counts" type="term_count_type"/>
    <place name="options" type="options_type" virtual="true"/>

    <transition name="split_init">
      <defun>
        <require key="worker" mandatory="true"/>
        <in name="in" type="unsigned int"/>
        <in name="options" type="options_type"/>
        <in name="step" type="string"/>
        <!--
        <inout name="active" type="unsigned int"/>
        -->
        <out name="out" type="list"/>
        <out name="counts" type="term_count_type"/>
        <module name="singular_parallel_allpfd"
                require_function_unloads_without_rest="false"
                function="out split_init
                            ( options
                            , in
                            , counts
                            , step
                            )">
          <cinclude href="interface/singular_pnet-interface.hpp"/>
          <cinclude href="util-generic/dynamic_linking.hpp"/>
          <cinclude href="iostream"/>
          <code><![CDATA[
            /*<>*/
            std::cout << "Initializing split "
                      << step << " "
                      << in
                      << "\n";

            singular_parallel::pnet_list indices = RESOLVE_INTERFACE_FUNCTION
               (pfd_fork_init)
               ( in
               , options
               , step
               );
            std::cout << step
                      << " "
                      << in
                      << " split into "
                      << indices.size()
                      << " terms.\n";

            counts.computing = indices.size();
            counts.total = indices.size();
            counts.id = in;

            std::cout << "Initializing split "
                      << step << " "
                      << in
                      << " done!\n";
            return indices;
          ]]></code>
        </module>
      </defun>
      <connect-in port="in" place="in"/>
      <!--
      <connect-in port="active" place="init_active"/>
      -->
      <connect-read port="options" place="options"/>
      <connect-read port="step" place="step"/>
      <connect-out-many port="out" place="terms"/>
      <!--
      <connect-out port="active" place="finish_active"/>
      -->
      <connect-out port="counts" place="term_counts"/>
    </transition>

    <transition name="fork_compute">
      <defun>
        <require key="worker" mandatory="true"/>
        <in name="term" type="term"/>
        <in name="options" type="options_type"/>
        <in name="step" type="string"/>
        <out name="out" type="term"/>
        <module name="singular_parallel_allpfd"
                require_function_unloads_without_rest="false"
                function="fork_compute
                            ( options
                            , term
                            , out
                            , step
                            )">
          <cinclude href="interface/singular_pnet-interface.hpp"/>
          <cinclude href="util-generic/dynamic_linking.hpp"/>
          <cinclude href="iostream"/>
          <code><![CDATA[
            /*<>*/

            RESOLVE_INTERFACE_FUNCTION
              (pfd_fork_compute_term)
              ( term.id, term.term_id, options , step);

            out = term;

          ]]></code>
        </module>
      </defun>
      <connect-in port="term" place="terms"/>
      <connect-read port="options" place="options"/>
      <connect-read port="step" place="step"/>
      <connect-out port="out" place="decomposed_terms"/>
    </transition>

    <transition name="collect_count_decomposed">
      <defun>
        <require key="worker" mandatory="true"/>
        <in name="terms" type="term"/>
        <inout name="counts" type="term_count_type"/>

        <condition>
          ${counts.computing} :gt: 0U :and:
          ${counts.id} :eq: ${terms.id}
        </condition>

        <expression>
          ${counts.computing} := ${counts.computing} - 1U;
        </expression>

      </defun>
      <connect-in port="terms" place="decomposed_terms"/>
      <connect-inout port="counts" place="term_counts"/>
    </transition>

    <transition name="merge_finish_step">
      <defun>
        <require key="worker" mandatory="true"/>
        <in name="options" type="options_type"/>
        <in name="step" type="string"/>
        <!--
        <inout name="active" type="unsigned int"/>
        -->
        <in name="counts" type="term_count_type"/>
        <out name="out" type="unsigned int"/>
        <condition>
          ${counts.computing} :eq: 0U
        </condition>
        <module name="singular_parallel_allpfd"
                require_function_unloads_without_rest="false"
                function="merge_finish_step
                             ( options
                             , counts
                             , out
                             , step
                             )">
          <cinclude href="interface/singular_pnet-interface.hpp"/>
          <cinclude href="util-generic/dynamic_linking.hpp"/>
          <cinclude href="iostream"/>
          <code><![CDATA[
            /*<>*/

            std::cout << "Merging and finishing "
                      << step
                      << " for problem "
                      << counts.id
                      << "\n";

            RESOLVE_INTERFACE_FUNCTION
               (pfd_fork_merge)
               ( counts.id, counts.total, options, step);

            RESOLVE_INTERFACE_FUNCTION
               (pfd_fork_finish)
               ( counts.id, options, step);

            out =counts.id;

            std::cout << "Merging and finishing "
                      << step
                      << " for problem "
                      << counts.id
                      << "\n";

          ]]></code>
        </module>
      </defun>
      <connect-read port="options" place="options"/>
      <!--
      <connect-in port="active" place="finish_active"/>
      -->
      <connect-in port="counts" place="term_counts"/>
      <connect-read port="step" place="step"/>
      <!--
      <connect-out port="active" place="init_active"/>
      -->
      <connect-out port="out" place="decomposition"/>
    </transition>
  </net>
</defun>

