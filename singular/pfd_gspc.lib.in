///////////////////////////////////////
version="version pfd_gspc.lib 0.1 Feb_2021 ";
category="Algebraic geometry";
info="";
proc mod_init()
{
  LIB "libSINGULAR-parallel-module.so";
  newstruct("configToken", "string tokentype, def options");
  newstruct("gspcConfigToken",
            "string tmpdir, " +
            "string nodefile, " +
            "int procspernode, " +
            "string rifstrategy, " +
            "string loghost, " +
            "int logport, " +
            "list addargs, " +
            "string loghostfile");
  newstruct("parallelConfigToken",
            "string instructname, " +
            "string instructdesc, " +
            "string outstructname, " +
            "string outstructdesc, " +
            "string neededlibrary, " +
            "string functionname, " +
            "string expandnodefunction, " +
            "string fromdir, " +
            "string todir, " +
            "int upperbound, " +
            "int loopmax, " +
            "int splitmax, " +
            "int sortinput, " +
            "int parprop"
            );
}

proc configure_gspc()
{
  gspcConfigToken gc;
  gc.rifstrategy = "ssh";
  configToken ct;
  ct.tokentype = "gspcConfigToken";
  ct.options = gc;
  return(ct);
}

proc configure_parallel()
{
  parallelConfigToken pc;
  configToken ct;
  ct.tokentype = "parallelConfigToken";
  ct.options = pc;
  return(ct);
}

proc extract_loghost_from_file(string loghostfile)
{
  string loghost = read(loghostfile);
  if ((loghost == "") || (loghost == newline))
  {
    ERROR("no hostname in loghostfile");
  }
  if (loghost[size(loghost)] == newline) // delete trailing LF
  {
    loghost = loghost[1..(size(loghost)-1)];
  }
  return (loghost);
}

proc get_loghost(configToken gc)
{
  if (gc.options.loghost == "") // no hostname given, so read from file
  {
    if (gc.options.loghostfile == "")
    {
      ERROR("logging requested, no loghost and no loghostfile given");
    }
    return (extract_loghost_from_file(gc.options.loghostfile));
  } else {
    return (gc.options.loghost);
  }
}

proc get_tmpdir(configToken gc)
{
  if (gc.options.tmpdir[1] == "/")
  {
    return (gc.options.tmpdir);
  }
  else
  {
    return (system("getenv", "PWD") + "/" + gc.options.tmpdir);
  }
}

proc get_parallel_launch_command(string ret_name, string tmpdir, string pnet_id)
{
  string common_args = "\"" + tmpdir + "\"" + ", " +
            "gc.options.nodefile, " +
            "gc.options.procspernode, " +
            "gc.options.rifstrategy, " +
            "gc.options.addargs, " +
            "pc.options.instructname, " +
            "pc.options.instructdesc, " +
            "pc.options.outstructname, " +
            "pc.options.outstructdesc, " +
            "pc.options.neededlibrary, " +
            "pc.options.functionname, " +
            "pc.options.fromdir, " +
            "pc.options.todir";
  if (pnet_id == "wait_first") {
    return ("def " + ret_name + " = sggspc_wait_first(l, " + common_args +
      ", 0, 0, pc.options.sortinput, 0);");
  }
  if (pnet_id == "wait_all") {
    return ("def " + ret_name + " = sggspc_wait_all(l, " + common_args +
      ", 0, 0, pc.options.sortinput, 0);");
  }
  if (pnet_id == "pfd") {
    return ("def " + ret_name + " = sggspc_pfd(l, " + common_args +
      ", pc.options.splitmax, pc.options.loopmax, " +
      "pc.options.sortinput, pc.options.parprop);");
  }
}

proc check_for_valid_pnet_id(string pnet_id)
{
  if ((pnet_id != "wait_all") &&
    (pnet_id != "wait_first") &&
    (pnet_id != "pfd")) {
    ERROR("Unknown function '" + pnet_id + ",' please give correct option");
  }
}

proc get_log_opts(configToken gc)
{
  if (gc.options.logport != 0) // logging requested
  {
    list logopt = list("--log-host",
                       get_loghost(gc),
                       "--log-port",
                       string(gc.options.logport));
  } else {
    list logopt = list();
  }
  return (logopt);
}

proc check_gspc_token_type(configToken gc)
{
  if (typeof(gc.options) != "gspcConfigToken") {
    ERROR("Expected a gspcConfigToken.  Instead, got a " gc.options);
  }
}

proc check_parallel_token_type(configToken pc)
{
  if (typeof(pc.options) != "parallelConfigToken") {
    ERROR("Expected a parallelConfigToken.  Instead, got a " pc.options);
  }
}

proc get_ldpathopt() {
  if (system("getenv", "LD_LIBRARY_PATH") != "")
  {
    list ldpathopt = list("--worker-env-copy-variable", "LD_LIBRARY_PATH");
  } else {
    list ldpathopt = list();
  }
  return (ldpathopt);
}

static proc parallel_wait(list l,
                          configToken gc,
                          configToken pc,
                          string pnet_id)
{
  check_gspc_token_type(gc);
  check_parallel_token_type(pc);

  gc.options.addargs = gc.options.addargs + get_log_opts(gc);
  gc.options.addargs = gc.options.addargs + get_ldpathopt();

  string tmpdir = get_tmpdir(gc);

  check_for_valid_pnet_id(pnet_id);

  string s_command = get_parallel_launch_command("sm_result", tmpdir, pnet_id);
  execute(s_command);
  return (sm_result);
}

proc parallel_waitfirst(list l, configToken gc, configToken pc)
{
  return(parallel_wait(l, gc, pc, "wait_first"));
}

proc parallel_waitall(list l, configToken gc, configToken pc)
{
  return(parallel_wait(l, gc, pc, "wait_all"));
}

proc parallel_waitpfd(list l, configToken gc, configToken pc)
{
  return(parallel_wait(l, gc, pc, "pfd"));
}

/*** PFD functions ***/

proc entry_filename(string matrixname, int row, int col)
{
  return (matrixname + "_" +string(row) + "_" + string(col))
}

proc default_gspc_config()
{
  configToken gc = configure_gspc();

  gc.options.tmpdir = "/dev/shm/@USER@/pfd_tmpfile";
  gc.options.nodefile = "@HOME@/nodefile";
  gc.options.procspernode = 8;
  gc.options.loghost = "@HOSTNAME@";
  gc.options.logport = 6439;

  while (gc.options.loghost[size(gc.options.loghost)] == newline) {
    gc.options.loghost = gc.options.loghost[1, size(gc.options.loghost) - 1];
  }
  system("sh", "mkdir -p " + gc.options.tmpdir);

  return (gc);
}

proc pfd_structs_config()
{
  configToken pc = configure_parallel();

  pc.options.instructname = "in_struct";
  pc.options.instructdesc = "string matrixname, int row, int col, " +
                            "string neededring, string fromdir, " +
                            "string todir, string suffix";
  pc.options.outstructname = "out_struct";
  pc.options.outstructdesc = "string result";
  pc.options.neededlibrary = "@PFD_SING_LIB_PATH@/pfd_singular_interface.lib";
  pc.options.functionname = "pfd_singular_compute";

  return (pc);
}

proc parallel_pfd ( string matrixname
                  , list entry_indices
                  , string fromdir
                  , list #
                  )
"USAGE:   parallel_pfd(matrixname, entry_indices, fromdir[, gc[, todir[, suffix]]), matrixname,fromdir,todir,suffix string,  entry_indicies list, gc configToken
PURPOSE:  apply @code{pfd} in parallel to the rational function saved in the
          files identified by the entry_indices corresponding to the entries of
          some matrix of rational funcitons
          @code{matrixname} is the prefix of the name of the txt-files containing
          the rational functions as a string, or in ssi format.
          @code{from_dir} and @{to_dir} are the directories (relative to current
          directory) of the input and output files respectively (default:
          current directory (?)).
"
{
  configToken gc, pc;
  int i, split_max, loop_max, sort_input, par_prop;

  list l;
  string todir, suffix;

  if (! defined(basering)) {
    ERROR("Please set the applicable ring required for the underlying polynomials");
    return(0);
  }

  if (size(#) >= 1) {
    gc = #[1];
  } else {
    gc = default_gspc_config();
  }


  if (size(#) >= 2) {
    todir = #[2];
  } else {
    todir = fromdir;
  }
  if (size(#) >= 3) {
    suffix = #[3];
  } else {
    suffix = "txt";
  }
  if (size(#) >= 4) {
    if ( typeof(#[4]) != "int") {
      ERROR("split_max requires an int");
    }
    split_max = #[4];
  } else {
    split_max = 8; // default value
  }
  if (size(#) >= 5) {
    if ( typeof(#[5]) != "int") {
      ERROR("loop_max requires an int");
    }
    loop_max = #[5];
  } else {
    loop_max = 20; // default value
  }

  if (size(#) >= 6) {
    if ( typeof(#[6]) != "int") {
      ERROR("sortinput requires an int");
    }
    sort_input = #[6];
  } else {
    sort_input = 1; // default value
  }

  if (size(#) >= 7) {
    if ( typeof(#[7]) != "int") {
      ERROR("parallel proportion requires an int");
    }
    par_prop = #[7];
  } else {
    par_prop = 5; // default value
  }

  pc = pfd_structs_config();
  pc.options.fromdir = fromdir;
  pc.options.todir = todir;
  pc.options.splitmax = split_max;
  pc.options.loopmax = loop_max;
  pc.options.sortinput = sort_input;
  pc.options.parprop = par_prop;

  newstruct(pc.options.instructname, pc.options.instructdesc);
  newstruct(pc.options.outstructname, pc.options.outstructdesc);
  in_struct ins;

  ins.matrixname = matrixname;
  ins.neededring = string(basering);
  ins.fromdir = fromdir;
  ins.todir = todir;
  ins.suffix = suffix;

  for (i = 1; i <= size(entry_indices); i++) {
      ins.row = entry_indices[i][1];
      ins.col = entry_indices[i][2];
      l[i] = ins;
  }

  def re_all = parallel_waitpfd(l,gc,pc);

  if (size(#) < 1) {
    system("sh", "rm -rv " + gc.options.tmpdir);
  }
  print (re_all);

  return (1);
}

proc  pfd_waitall( string matrixname
                         , list entry_indices
                         , string fromdir
                         , list #
                         )
{
  configToken gc;

  int sort_input;

  string todir, suffix;



  if (size(#) >= 1) {
    gc = #[1];
  } else {
    gc = default_gspc_config();
  }
  if (size(#) >= 2) {
    todir = #[2];
  } else {
    todir = fromdir;
  }
  if (size(#) >= 3) {
    suffix = #[3];
  } else {
    suffix = "txt";
  }

  if (size(#) >= 4) {
    if ( typeof(#[4]) != "int") {
      ERROR("sortinput requires an int");
    }
    sort_input = #[4];
  } else {
    sort_input = 1; // default value: True
  }

  parallel_pfd( matrixname
              , entry_indices
              , fromdir
              , gc
              , todir
              , suffix
              , 1 // max_split irrelevant in serial
              , 1 // max_loop irrelevant in serial
              , sort_input
              , 0 // serial, so 0% internal parallel
              );
}

proc  pfd_fullyparallel( string matrixname
                           , list entry_indices
                           , string fromdir
                           , list #
                           )
{
  configToken gc;

  int split_max, loop_max, sort_input;

  string todir, suffix;

  if (size(#) >= 1) {
    gc = #[1];
  } else {
    gc = default_gspc_config();
  }
  if (size(#) >= 2) {
    todir = #[2];
  } else {
    todir = fromdir;
  }
  if (size(#) >= 3) {
    suffix = #[3];
  } else {
    suffix = "txt";
  }

  if (size(#) >= 4) {
    if ( typeof(#[4]) != "int") {
      ERROR("split_max requires an int");
    }
    split_max = #[4];
  } else {
    split_max = 8; // default value
  }
  if (size(#) >= 5) {
    if ( typeof(#[5]) != "int") {
      ERROR("loop_max requires an int");
    }
    loop_max = #[5];
  } else {
    loop_max = 50; // default value
  }

  if (size(#) >= 6) {
    if ( typeof(#[6]) != "int") {
      ERROR("sortinput requires an int");
    }
    sort_input = #[6];
  } else {
    sort_input = 1; // default value: True
  }

  parallel_pfd( matrixname
              , entry_indices
              , fromdir
              , gc
              , todir
              , suffix
              , split_max
              , loop_max
              , sort_input
              , 100 // parallel, so 100% internal parallel
              );
}

/*** companion functions ***/

proc companion_structs_config()
{
  configToken pc = configure_parallel();

  pc.options.instructname = "in_struct";
  pc.options.instructdesc = "int index, " +
                            "string rootdir";
  pc.options.outstructname = "out_struct";
  pc.options.outstructdesc = "string result";
  pc.options.neededlibrary = "@PFD_SING_LIB_PATH@/companion_gspc_interface.lib";
  pc.options.functionname = "companion_gspc_compute";

  return (pc);
}

proc parallel_companion ( string rootdir
                        , list file_indices
                        , list #
                        )
"USAGE:   parallel_companion(rootdir, file_indices[, gc]), rootdir string,  file_indicies list, gc configToken
PURPOSE:  apply @code{companion} in parallel to the data saved in the
          files identified by the file_indices.
          @code{rootdir} is the path to the directory relative to which the
          input files will be found and the output will be written.
"
{
  configToken gc, pc;
  int i;
  list l;

  /*
  if (! defined(basering)) {
    ERROR("Please set the applicable ring required for the underlying polynomials");
    return(0);
  }
  */

  if (size(#) >= 1) {
    gc = #[1];
  } else {
    gc = default_gspc_config();
  }


  pc = companion_structs_config();

  newstruct(pc.options.instructname, pc.options.instructdesc);
  newstruct(pc.options.outstructname, pc.options.outstructdesc);
  in_struct ins;

  ins.rootdir = rootdir;

  for (i = 1; i <= size(file_indices); i++) {
      ins.index = file_indices[i];
      l[i] = ins;
  }

  def re_all = parallel_waitall(l,gc,pc);

  if (size(#) < 1) {
    system("sh", "rm -rv " + gc.options.tmpdir);
  }
  print (re_all);

  return (1);
}
